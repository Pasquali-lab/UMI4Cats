---
title: "Analyzing UMI-4C data with UMI4Cats"
author: "Mireia Ramos-Rodríguez and Marc Subirana-Granés"
package: UMI4Cats
bibliography: bibliography.bib
output: 
  BiocStyle::html_document:
    fig_width: 7
    fig_height: 5
vignette: >
  %\VignetteIndexEntry{Analyzing UMI-4C data with UMI4Cats}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.align = "center"
)
```

```{r, echo=FALSE, eval=TRUE}
knitr::include_graphics("../man/figures/UMI4Cats.png", dpi=800)
```

# Introduction

Hello stranger! If you are here, that means you've successfully completed the UMI-4C protocol and got some sequencing results! This vignette has the objective to guide you through performing a simple analysis of your brand-new UMI-4C contact data. Let's dive in!

```{r}
library(UMI4Cats)
```

## Overview of the package

```{r, echo=FALSE, eval=TRUE, fig.cap="Overview of the different functions included in the UMI4Cats package to analyze UMI-4C data."}
knitr::include_graphics("figures/scheme.png", dpi=400)
```

## About the experimental design

One of the streghts of the UMI-4C assay [@Schwartzman2016] is that it allows to recude the PCR duplication bias, thus allowing more accurate quantification of chormatin interactions. For this reason, UMI-4C is mostly used when trying to compare changes in chromatin interactions between two conditions, cell types or developmental stages. 

Taking into account this main application, UMI4Cats has been developed to facilitate the differential analysis between condition at a given viewpoint of interest. When analyzing your data with this package, you should take into account the following points: 

- Each analysis (and `UMI4C` object) should correspond to the **same viewpoint**. If you are analyzing different viewpoints in 
the same or different loci, you need to analyze them separately. 

- The UMI4Cats package is mostly oriented to the performance of differential analysis. For this reason, in the analysis step, it requires to **annotate each sample "replicate" and "condition"**. However, if you only have one replicate or condition you will be able to perform the analysis and visualization of the data -- minus the differential analysis.

- When performing the differential analysis, UMI4Cats is only able to deal with a **condition with 2 different levels**. If you have more than two conditions, you should produce different UMI4C objects with the pairwise comparisons.

## About the example datasets

The datasets used in this vignette are easily available for download if you want to reproduce the contents of this vignette and are published in @Ramos-Rodriguez2019.

Briefly, the datasets correspond to human pancreatic islets exposed (`cyt`) or not (`ctrl`) to pro-inflammatory cytokines for 48 hours. In this example we are using the UMI-4C data generated from two different biological replicates (HI19 and HI22) using the promoter of the *SOCS1* gene as viewpoint.

# Quick start

In this section we summarize a complete analysis using the examples provided in this package. If you are interested to know more in detail the capabilities of the different functions, you can skip to the following sections. 

```{r processing-quick-start, eval=FALSE}
## 0) Download example data -------------------------------
path <- downloadUMI4CexampleData()

## 1) Generate Digested genome ----------------------------
# The selected RE in this case is DpnII (|GATC), so the cs5p is "" and cs3p is GATC
hg19_dpnii <- digestGenome(cut_pos = 0,
                           res_enz = "GATC",
                           name_RE = "DpnII",
                           ref_gen = BSgenome.Hsapiens.UCSC.hg19::BSgenome.Hsapiens.UCSC.hg19, 
                           out_path = "digested_genome/")

## 2) Process UMI-4C fastq files --------------------------
raw_dir <- file.path(path, "SOCS1", "fastq")

contactsUMI4C(fastq_dir = raw_dir,
              wk_dir = "SOCS1",
              bait_seq = "CCCAAATCGCCCAGACCAG",
              bait_pad = "GCGCG",
              res_enz = "GATC",
              cut_pos = 0,
              digested_genome = hg19_dpnii,
              bowtie_index = file.path(path, "ref_genome", "ucsc.hg19.chr16"),
              ref_gen = BSgenome.Hsapiens.UCSC.hg19::BSgenome.Hsapiens.UCSC.hg19,
             threads = 5)
``` 

```{r analysis-quick-start}
## 3) Get filtering and alignment stats -------------------
statsUMI4C(wk_dir = system.file("extdata", "SOCS1",
                               package="UMI4Cats"))

## 4) Analyze the results ---------------------------------
# Load sample processed file paths
files <- list.files(system.file("extdata", "SOCS1", "count", 
                                package="UMI4Cats"),
                    pattern="*_counts.tsv.gz",
                    full.names=TRUE)

# Create colData including all relevant information
colData <- data.frame(sampleID = gsub("_counts.tsv.gz", "", basename(files)),
                      file = files,
                      stringsAsFactors=FALSE)

library(tidyr)
colData <- colData %>% 
  separate(sampleID, 
           into=c("condition", "replicate", "viewpoint"),
           remove=FALSE)

# Load UMI-4C data and generate UMI4C object
umi <- makeUMI4C(colData=colData,
                 viewpoint_name="SOCS1")

## 5) Perform differential test ---------------------------
umi <- fisherUMI4C(umi,
                   filter_low = 20)

## 6)  Plot results ---------------------------------------
plotUMI4C(umi, 
          ylim=c(0,10),
          xlim=c(11e6, 11.5e6)
          )
```


# Preparing necessary files

## Demultiplexing fastQ files containing multiple baits

One of the many advantages of using the UMI-4C protocol is that it allows multiplexing of different baits using the same sample. 

To facilitate the analysis, UMI4Cats  provides a function for demultiplexing the paired-end FastQ files returned by the sequencing facility. The barcode sequences and names to be used for each output sequences need to be provided as a `data.frame` with column names `sample` and `barcode`. 

```{r, eval=FALSE}
barcodes <- data.frame(sample=c("sample1_KLK3", "sample1_KLK6", "sample1_KLK7", "sample1_KLK10"),
                      barcode=c("ATGGTCTGGGCGCTGTCTTG",
                                "TATTCTTCCTCAGCCCACATCTT",
                                "GGATGAAGATTTTGGAGCCCAGC",
                                "GGGCGGGGATTGAACGC"))

demultiplexFastq(barcodes=barcodes,
                fastq="~/samples/sample_1_R1.fastq.gz",
                out_path="raw_fastq")
```

## Reference genome digestion
For the processing of the UMI-4C fastQ files it is necessary to construct a digested genome using the same restriction enzyme used in the UMI-4C experiments.

The `UMI4Cats` package includes the `digestGenome()` function to make this process as easy as possible. The function uses a `BSgenome` object^[More information on `BSgenome` package and objects can be found [here](https://bioconductor.org/packages/release/bioc/html/BSgenome.html)] as reference genome and given a cutting sequence (`res_enz`) for the restriction enzyme, digests the reference genome.

Besides the restriction sequence, it is also necessary to provide the position at which the restriction enzyme cuts (`cut_pos`) as a zero-based numeric integrer indicating the nucleotide position in the restriction sequence.

In the following table you can see three examples of the different cutting sequences for *DpnII*, *Csp6I* and *HindIII*.

Restriction enzyme | Restriction seq | `res_enz` | `cut_pos`
-------------------|-----------------|-----------|---------
DpnII              | :`GATC`         | GATC      | 0        
Csp6I              | `G`:`TAC`       | GTAC      | 1    
HindIII            | `A`:`AGCTT`     | AAGCTT    | 1       

For this example, we are using the hg19 `BSGenome` object and we are going to digest it using the *DpnII* enzyme. 

```{r}
library(BSgenome.Hsapiens.UCSC.hg19)
refgen <- BSgenome.Hsapiens.UCSC.hg19

hg19_dpnii <- digestGenome(res_enz = "GATC",
                           cut_pos = 0,
                           name_RE = "dpnII",
                           ref_gen = refgen, 
                           sel_chr = "chr16",
                           out_path = "digested_genome/")

hg19_dpnii
```

The digested genome will be saved in the folder provided in `out_path` as RData objects divided by chromosome. Additionally, the function returns invisibly the path of the generated digested genome, so you can redirect it to a variable (in this case `hg19_dpnii`) and use it for downstream analyses.

# Processing UMI-4C FASTQ files

This step converts paired-end reads in the FastQ files to UMI counts in the genome fragments digested *in silico* using the restriction enzymes. The function for doing this analysis is `contactsUMI4C()` and should be ran in samples generated with the same viewpoint and restriction enzyme. 

The function will consider all FastQ files in the same folder `fastq_dir` to be part of the same experiment (viewpoint + restriction enzyme). However, if you want to specify a subset of samples in which to perform the analysis you can do so using the `file_pattern` argument. This way, only the files matching the specified pattern will be use for the analyses.

The different pairs for each sample should be named `_R1` or `_R2` and the function accepts the following fastq suffixes: `.fastq`, `.fq`, `.fq.gz` or `.fastq.gz`.

For every experiment processing, the user needs to define 3 different sequences:

- **Bait/viewpoint sequence** (`bait_seq`). This is the downstream primer sequence (DS primer) that matches the sequence of the queried bait.
- **Padding sequence** (`bait_pad`). The padding sequence corresponds to the nucleotides betweeen the DS primer end and the restriction enzyme site.
- **Restriction enzyme sequence** (`res_enz`). This sequence is the restriction sequence recognized by the selected restriction enzyme.

```{r, echo=FALSE, eval=TRUE, fig.cap="Schematic of a UMI-4C read detailing the different elements that need to be used as input for the processing of the data."}
knitr::include_graphics("figures/read_scheme.png", dpi=350)
```

Additionally, it is necessary to define the restiction enzyme cutting postion (`cut_pos`) the same way as we did for generating the digested genome. The function will also need the path for the digested genome (`digested_genome`) generated with the function `digestGenome()`.

As `contactsUMI4C()` performs the alignment using [Bowtie2](http://bowtie-bio.sourceforge.net/bowtie2/index.shtml), you will also need to provide 
the reference genome indexes generated with bowtie2^[See the [getting started section](http://bowtie-bio.sourceforge.net/bowtie2/manual.shtml#getting-started-with-bowtie-2-lambda-phage-example) on the Bowtie2 page for more information on how to generate the index for the reference genome.]. Remember to make sure that your reference genome and digested genome correspond to the same build (in this example, hg19). 

```{r processing, message=TRUE}
## Download sample dataset
path <- downloadUMI4CexampleData()

## Processing of fastq files
raw_dir <- file.path(path, "SOCS1", "fastq")

contactsUMI4C(fastq_dir = raw_dir,
              wk_dir = "SOCS1",
              file_pattern="ctrl_hi19_SOCS1", # Select only one sample to reduce time
              bait_seq = "CCCAAATCGCCCAGACCAG",
              bait_pad = "GCGCG",
              res_enz = "GATC",
              cut_pos = 0,
              digested_genome = hg19_dpnii,
              bowtie_index = file.path(path, "ref_genome", "ucsc.hg19.chr16"),
              ref_gen = BSgenome.Hsapiens.UCSC.hg19::BSgenome.Hsapiens.UCSC.hg19,
              threads = 10)

```

Internally, `contactsUMI4C()` will then run the following processes sequentially:

1. FastQ files preparation (`prepUMI4C`). In this preprocessing step, only reads containin the `bait_seq` + `bait_pad` + `res_enz` will be selected. Also, reads with mean Phread quality scores < 20 will be filtered out.
2. Split reads at restriction sites (`splitUMI4C`). Using the `res_enz` sequence, all reads from R1 and R2 will be split at this sequences to mimic the fragments that were generated experimentally.
3. Align split reads to the reference genome (`alignmentUMI4C`). 
4. Collapse reads coming from same molecule (PCR duplicates) using the UMI (`counterUMI4C`). It will return all fragment ends 10Mb around the viewpoint.

**Note on memory usage**: For the preparation and splitting, the FastQ file is loaded into memory. If you are having problems with the memory size, you can change the number of lines to be loaded using the `numb_reads` parameter. See `?contactsUMI4C` for more information.

Finally, the output (UMI-4C counts) is a tsv file per sample that will be saved in `wk_dir/count`. These files will be the input for the data analysis in the following section.

## Quality control measures
Once the processing step has been ran, the statistics of the UMI-4C filtering, aligment and final number of UMIs can be generated from the logs generated by the `contactsUMI4C()` function. 

By using these logs, the function `statsUMI4C()` will produce a summary plot  and a summary table with all statistics (in `wk_dir/logs/stats_summary.txt`). 

```{r}
statsUMI4C(wk_dir = system.file("extdata", "SOCS1",
                                package="UMI4Cats"))

stats <- read.delim(system.file("extdata", "SOCS1", "logs", "stats_summary.txt", 
                                package="UMI4Cats"))

knitr::kable(stats)
```

The quality control measures summarized both in the plot and the table are:

- **Specific reads**. Corresponds to the number of reads that contained the full viewpoint sequence (`bait_seq` + `bait_pad` + `res_enz`).
- **Filtered reads**. A quality filtering to ensure that filtered (or kept) reads have a mean Phred quality score `>= 20`.
- **Mapping stats**. Indicates how many split reads are mapped or unmapped to the reference genome.
- **UMIs**. Shows the final number of contact molecules that were detected from the experiment. 

# Analyzing UMI-4C data

After the processing of the fastQ reads into tables summarizing contacts and the number of UMIs supporting that interaction with the viewpoint, the next step is to analyze the data, detect differential contacts and visualize the genomic interactions.

## Construct the `UMI4C` object

The first step of the UMI-4C data analysis consists on loading the tables generated by the function `contactsUMI4C()` and use them to construct a `UMI4C` object. All these steps are performed automatically by the `makeUMI4C()` function. 

The `makeUMI4C` will need as imput a data frame (`colData`) containing all relevant experiment information that will be needed for analyzing the data later on. The mandatory columns that this data frame should have are:

1. `sampleID`: Unique identifier for the sample.
2. `replicate`: Replicate identifier or number.
3. `condition`: Condition for performing the diferential analysis. For example: "control" and "treatment", two different cell types, etc. The condition column should only have **two** different values. If more condition variables are provided, the differential analysis will fail.
4. `file`: Complete path and filename where the tsv files generated by `contactsUMI4C` are saved.

You can also include other additional columns to `colData`.

By default, the function will combine the samples using the **condition** column from `colData`, but you can change this behaviour using the `grouping` argument in `makeUMI4C()`. For example, if you set `grouping="sampleID"` it will plot the individual profiles or if you set `grouping="replicate"` your samples will be summarized according to the replicates you provided in `colData`.

Additionally, the `makeUMI4C` function also contains other arguments that can be used if you want to tweak the default parameters of the analysis. See `?makeUMI4C` to have a complete list and description of all the arguments.

```{r}
# Load sample processed file paths
files <- list.files(system.file("extdata", "SOCS1", "count", 
                                package = "UMI4Cats"),
                    pattern = "*_counts.tsv",
                    full.names = TRUE)

# Create colData including all relevant information
colData <- data.frame(sampleID = gsub("_counts.tsv.gz", "", basename(files)),
                      file = files,
                      stringsAsFactors = FALSE)

library(tidyr)
colData <- colData %>% 
  separate(sampleID, 
           into = c("condition", "replicate", "viewpoint"),
           remove = FALSE)

# Load UMI-4C data and generate UMI4C object
umi <- makeUMI4C(colData = colData,
                 viewpoint_name = "SOCS1")

umi
```

The `makeUMI4C` function will perform the following steps to generate the `UMI4C` object:

1. **Remove fragment ends around the bait**, as they are generally biased because of their proximity to the viewpoint. The default value of the region that will be excluded from the analysis can be specified using the `bait_exclusion` argument.
2. **Focus the scope** of the analysis in a specific window around the bait, by default 2Mb around the viewpoint. The default value can be changed using the `bait_expansion` argument.
3. Sum the UMIs of the different samples belonging to the sampe group (defined by the `grouping` variable).
4. Obtain the normalization matrices that will be used to scale the groups to the reference, by default the group with less UMIs. If you want to avoid this normalization step, you can set `normalized` to `FALSE`.
5. Calculate the domainograms for each group.
6. Calculate the adaptative trend for each group.

### Accessing information from the `UMI4C` object

The usual accessor functions from the `SummarizedExperiment-class` also work with the UMI-4C class (for example: `assay`, `colData`, etc.). Other additional accessors have been created to retrieve different information:

- `dgram()`. Get a list of the domaingorams for each group.
- `bait()`. Retrieve a GRanges object with the bait position.
- `trend()`. Obtain a data.frame in long format with the adaptative smoothen trend.
- `results()`. Retrieve results from the differential analysis. This only works if a differential analysis has been performed on the UMI4C object.

```{r}
head(assay(umi))

colData(umi)

dgram(umi)

bait(umi)

head(trend(umi))
```

## Performing differential analysis

Once the `UMI4C` object is generated, one can perform a differential analysis using the `fisherUMI4C()` function, that takes as input the `UMI4C` object. 

If no other argument is provided, it will bin the region around the viewpoint and perform Fisher's Exact tests in those bins, comparing the number of reads in each condition at that specific window with the number of reads in the studied region. Finally, p-values will be corrected for multiple testing using the FDR method and regions with adjusted p-values > 0.05 will be considered signficantly different. 

The `filter_low` arguments determines which bins are tested: if they do not contain at least the number of UMIs in `filter_low`, they will not be tested. If you want to disable the filtering you can set `filter_low=FALSE`. You can also change the size of the windows used for this analysis using the `window_size` argument. Check `?fisherUMI4()` for more information.

If you are interested in testing the differential contacts in specific genomic regions, you can provide them using the `query_regions` argument.

Results from this test can be retrieved using the `results()` method defined for `UMI4C` objects.

```{r}
umi_dif <- fisherUMI4C(umi,
                   filter_low=20)

results(umi_dif, ordered=TRUE)
```
 

# Visualizing UMI-4C contact data

Once the `UMI4C` object is created, you can plot it using the `plotUMI4C` function. 

```{r}
plotUMI4C(umi)
```

The domainogram plotting is controlled by the `dgram_plot` argument. If you set it to `FALSE`, the domainogram will not be plotted.

```{r}
plotUMI4C(umi, dgram_plot=FALSE)
```

If the `UMI4C` object contains information on the differential contacts, this data will be shown in the plot as well.

```{r}
plotUMI4C(umi_dif)
```

There are many arguments you can give to `plotUMI4C` to modify the output plot. You can check them at `?plotUMI4C`.

The `plotUMI4C` function is a wrapper for separate functions that plot the different elements included in the figure. You can use each of the functions separately if you are interesting in combining them differently or with other ggplot2 objects. Check each function documentation at `?plotTrend`, `?plotGenes`, `?plotDomainogram` and `?plotDifferential`.

# References

