#' Plot UMI4C data
#'
#' Produce a full UMI4C data plot containing the genes in the region, the adaptative smoothen trend and
#' the domainogram.
#' @param umi4c UMI4C object as generated by \code{makeUMI4C} or the \code{UMI4C} constructor.
#' @param grouping Name of the \code{colData(UMI4C)} column that will be used for grouping the profiles. If it is
#' vector of column names, will use both columns for grouping the samples.
#' @param dgram_function The name of the function used for calculating the fold-change in the domainogram plot,
#' either "difference" or "quotient".
#' @param dgram_plot Logical indicating whether to plot the domainogram. If the \code{umi4c} object only contains
#' one sample will be automatically disabled.
#' @param colors Vector of colors to use for plotting for each group.
#' @param ylim Limits of the trend y axis.
#' @param xlim Limits for the plot x axis (genomic coordinates).
#' @param protein_coding Logical indicating whether to only plot protein coding genes in the gene
#' annotation part.
#' @param longest Logical indicating whether to plot only the longest transcripts for each gene in the
#' gene annotation part.
#' @param rel_heights Numeric vector of length 3 indicating the relative heights of each part of the UMI4C plot.
#' @param font_size Base font size to use for the UMI4C plot.
#' @examples \dontrun{
#' umi <- makeUMI4Cexample()
#'
#' plotUMI4C(umi)
#' }
#' @import magick
#' @export
plotUMI4C <- function(umi4c,
                      grouping="condition",
                      dgram_function="quotient",
                      dgram_plot=TRUE,
                      colors=NULL,
                      xlim=NULL,
                      ylim=NULL,
                      protein_coding=TRUE,
                      longest=TRUE,
                      rel_heights=c(0.25, 0.4, 0.12,0.23),
                      font_size=14) {

  if (is.null(xlim)) {
    xlim <- c(GenomicRanges::start(metadata(umi4c)$region),
            GenomicRanges::end(metadata(umi4c)$region))
  }

  if (is.null(ylim)) {
    ylim <- c(0,
              max(trend(umi4c)$trend, na.rm=TRUE))
  }

  ## Get colors
  factors <- unique(colData(umi4c)[,grouping])
  if (class(factors)=="DataFrame") factors <- do.call(paste,  as.list(colData(umi4c)[,grouping]))

  if (is.null(colors)) colors <- getColors(factors)

  if (length(dgram(umi4c))==1 | length(factors)>2) dgram_plot <- FALSE

  ## TODO: Create UMI4C object with only two samples: factor
  # if (length(factors)==2) {
  #   coldata_ori <- colData(umi4c)
  #   coldata <- coldata_ori
  #   rownames(coldata) <- NULL
  #   coldata$sampleID <- coldata_ori[,grouping]
  #   coldata <- unique(coldata[,(colnames(coldata) %in% c("sampleID", grouping))])
  #
  #   umis <- assay(umi4c)
  #   fact1 <- rowSums(assay(umi4c)[,sapply(coldata_ori$sampleID[coldata_ori[,grouping]==factors[1]],
  #                               grep, colnames(assay(umi4c)))])
  #   fact2 <- rowSums(assay(umi4c)[,sapply(coldata_ori$sampleID[coldata_ori[,grouping]==factors[2]],
  #                        grep, colnames(assay(umi4c)))])
  #
  #   umis <- cbind(fact1, fact2)
  #   colnames(umis) <- factors
  #
  #   ## Make new UMI4C object
  #   umi4c <- UMI4C(colData=coldata,
  #                      rowRanges=rowRanges(umi4c),
  #                      metadata=list(bait=bait(umi4c),
  #                                    scales=metadata(umi4c)$scales,
  #                                    min_win_factor=metadata(umi4c)$min_win_factor),
  #                      assays=SimpleList(umis=umis))
  #
  #   ## Get normalization matrix
  #   metadata(umi4c)$ref_umi4c <- colnames(assay(umi4c))[which(colSums(assay(umi4c))==min(colSums(assay(umi4c))))]
  #   umi4c <- getNormalizationMatrix(umi4c)
  #
  #   ## Calculate domainograms
  #   umi4c <- calculateDomainogram(umi4c,
  #                                 scales=umi4c$metadata$scales,
  #                                 normalized=T)
  #
  #   ## Calculate adaptative trend
  #   umi4c <- calculateAdaptativeTrend(umi4c,
  #                                     sd=sd,
  #                                     normalized=T)
  # }

  trend_plot <- plotTrend(umi4c,
                          grouping=grouping,
                          xlim=xlim,
                          ylim=ylim,
                          colors=colors)


  genes_plot <- plotGenes(window=metadata(umi4c)$region,
                          protein_coding=protein_coding,
                          longest=longest,
                          xlim=xlim)

  if (dgram_plot & length(umi4c@results)>0) { # Draw both dgram & diff
    # Plot domainogram
    domgram_plot <- plotDomainogram(umi4c,
                                  grouping=grouping,
                                  dgram_function=dgram_function,
                                  colors=colors,
                                  xlim=xlim) + cowplot::theme_cowplot(font_size)
    # Plot differntial
    diff_plot <- plotDifferential(umi4c,
                                  grouping=grouping,
                                  colors=colors,
                                  xlim=xlim)

    # Empty theme for trend
    trend_theme <- cowplot::theme_cowplot(font_size) + themeXblank(legend.position="bottom",
                                                          legend.justification="center")
    # Empty theme for diff
    diff_theme <- cowplot::theme_cowplot(font_size) + themeXYblank(legend.position="bottom",
                                                                  legend.justification="center")
  } else if (!dgram_plot & length(umi4c@results)>0) {
    domgram_plot <- NULL
    # Plot differntial
    diff_plot <- plotDifferential(umi4c,
                                  colors=colors,
                                  grouping=grouping,
                                  xlim=xlim)

    # Empty theme for trend
    trend_theme <- cowplot::theme_cowplot(font_size) + themeXblank(legend.position="bottom",
                                                                   legend.justification="center")
    # X axis theme for diff
    diff_theme <- cowplot::theme_cowplot(font_size) + themeYblank(legend.position="bottom",
                                                             legend.justification="center")
  } else if(dgram_plot & !(length(umi4c@results)>0)) {
    # Plot domainogram
    domgram_plot <- plotDomainogram(umi4c,
                                    grouping=grouping,
                                    dgram_function=dgram_function,
                                    colors=colors,
                                    xlim=xlim) + cowplot::theme_cowplot(font_size)
    # Plot differntial
    diff_plot <- NULL

    # Empty theme for trend
    trend_theme <- cowplot::theme_cowplot(font_size) + themeXblank(legend.position="bottom",
                                                                   legend.justification="center")
    # Empty theme for diff
    diff_theme <- cowplot::theme_cowplot(font_size) + themeXYblank(legend.position="bottom",
                                                                  legend.justification="center")
  } else {
    # Plot domainogram
    domgram_plot <- NULL
    # Plot differntial
    diff_plot <- NULL

    # X axis theme for trend
    trend_theme <- cowplot::theme_cowplot(font_size) + ggplot2::theme(legend.position="bottom",
                                                                   legend.justification="center")

    # Empty theme for diff
    diff_theme <- cowplot::theme_cowplot(font_size) + themeXYblank(legend.position="bottom",
                                                                     legend.justification="center")
  }


  ## Select appropriate themes for trend and/or differential plot
  umi4c_plot <- list(genes_plot + cowplot::theme_nothing(font_size),
                     trend_plot + trend_theme,
                     diff_plot + diff_theme,
                     domgram_plot + ggplot2::theme(legend.position="bottom"))

  ## Remove dgram data if dgram_plot is false
  umi4c_keep <- !sapply(umi4c_plot, is.null)

  if (any(!umi4c_keep)) {
    umi4c_plot <- umi4c_plot[umi4c_keep]
    rel_heights <- rel_heights[umi4c_keep]
  }


  ## Extract legends and plot them separately
  legends <- lapply(umi4c_plot[-1], cowplot::get_legend)
  legends_plot <- cowplot::plot_grid(plotlist=legends, nrow=1, align="h")

  ## Remove legends from plot
  umi4c_plot <- lapply(umi4c_plot, function(x) x + ggplot2::theme(legend.position="none"))

  ## Plot main
  main_plot <- cowplot::plot_grid(plotlist=umi4c_plot,
                                  ncol=1,
                                  align="v",
                                  rel_heights=rel_heights)

  cowplot::plot_grid(legends_plot, main_plot,
                     ncol=1,
                     rel_heights = c(0.15,0.85))

}

#' Plot differential contacts
#'
#' @inheritParams plotUMI4C
#' @export
plotDifferential <- function(umi4c,
                             grouping="condition",
                             colors=NULL,
                             xlim=NULL) {
  factors <- unique(colData(umi4c)[,grouping])
  if (is.null(colors)) colors <- getColors(factors)

  diff <- results(umi4c, format="data.frame", counts=FALSE)

  # Get coordinates for plotting squares
  if (grepl("DESeq2", umi4c@results$test)) {
    diff$end <- c(diff$start[-1],
                  diff$start[nrow(diff)])
    legend <- expression("Log"[2]*" FC")
  } else {
    legend <- expression("Log"[2]*" OR")
  }

  fill_variable <- colnames(diff)[grep("log2", colnames(diff))]

  diff_plot <-
    ggplot2::ggplot(diff) +
    ggplot2::geom_rect(ggplot2::aes_string(xmin="start",
                                    xmax="end",
                                    ymin=0, ymax=1,
                                    fill=fill_variable)) +
    ggplot2::geom_point(ggplot2::aes(x=start+((end-start)/2),
                                     y=1.15, shape=sign)) +
    ggplot2::scale_fill_gradient2(low=colors[1],
                                  mid="grey",
                                  high=colors[2],
                                  midpoint=0,
                                  na.value = NA,
                                  name=legend,
                                  breaks=scales::pretty_breaks(n=4),
                                  limits=c(-3,3),
                                  guide = ggplot2::guide_colorbar(direction = "horizontal",
                                                                  title.position="top",
                                                                  barwidth=8)) +
    ggplot2::scale_shape_manual(values=c("TRUE"=8, "FALSE"=NA),
                                guide=FALSE) +
    themeYblank() +
    ggplot2::scale_x_continuous(labels=function(x) round(x/1e6,2),
                                name=paste("Coordinates",
                                           GenomicRanges::seqnames(bait(umi4c)),
                                           "(Mb)")) +
    ggplot2::coord_cartesian(xlim=xlim) +
    ggplot2::guides(fill=ggplot2::guide_colorbar(title.position="left",
                                                 label.position="bottom",
                                                 title.vjust=1,
                                                 direction="horizontal"))

  return(diff_plot)
}

#' Plot domainogram
#'
#' @inheritParams plotUMI4C
#' @export
plotDomainogram <- function(umi4c,
                            grouping="condition",
                            dgram_function="quotient", # or "difference"
                            colors=NULL,
                            xlim=NULL) {
  factor <- unique(colData(umi4c)[, grouping])
  if (class(factor)=="DataFrame") factor <- do.call(paste, colData(umi4c)[,grouping])

  if (is.null(colors)) colors <- getColors(factors)

  if (length(factor)>2) stop("Error in 'plotDomainogram':\n
                             dgram_grouping' cannot have more than two levels. Choose another
                             variable for grouping or refactor the column to only have two levels.")

  dgram <- dgram(umi4c)

  ## Sum dgrams from same factor
  ids_1 <- colData(umi4c)$sampleID[grep(factor[1], colData(umi4c)[,grouping])]
  ids_2 <- colData(umi4c)$sampleID[grep(factor[2], colData(umi4c)[,grouping])]

  dgram_merged <- list()
  dgram_merged[[factor[1]]] <- Reduce('+', dgram[ids_1])
  dgram_merged[[factor[1]]][is.na(dgram_merged[[factor[1]]])] <- 0

  dgram_merged[[factor[2]]] <- Reduce('+', dgram[ids_2])
  dgram_merged[[factor[2]]][is.na(dgram_merged[[factor[2]]])] <- 0

  ## Create dgram of difference
  if (dgram_function=="difference") {
    dgram_diff <- log2(1 + dgram_merged[[factor[2]]]) - log2(1 + dgram_merged[[factor[1]]])
    lab_legend <- " diff"
  } else if (dgram_function=="quotient") {
    dgram_diff <- log2(dgram_merged[[factor[2]]]/dgram_merged[[factor[1]]])
    lab_legend <- " FC"
  }

  ## Create melted dgram
  dgram_diff <- reshape2::melt(dgram_diff)
  colnames(dgram_diff) <- c("contact_id", "scales", "value")

  ## Add coordinates
  dgram_diff$start <- rep(GenomicRanges::start(umi4c),
                          length(unique(dgram_diff$scales)))
  dgram_diff$end <- rep((GenomicRanges::start(umi4c)[c(2:length(umi4c), length(umi4c))] -
                           GenomicRanges::start(umi4c)) + GenomicRanges::start(umi4c),
                        length(unique(dgram_diff$scales)))


  dgram_plot <-
    ggplot2::ggplot(dgram_diff) +
    ggplot2::geom_rect(ggplot2::aes(xmin=start, xmax=end,
                                    ymin=scales, ymax=scales+1,
                                    fill=value)) +
    ggplot2::scale_fill_gradientn(colors=c(darken(colors[1], factor=10),
                                           colors[1], "white",
                                           colors[2],
                                           darken(colors[2], factor=10)),
                                  na.value = NA,
                                  name=as.expression(bquote(Log[2]*" UMIs"*.(lab_legend))),
                                  breaks=scales::pretty_breaks(n=4),
                                  guide = ggplot2::guide_colorbar(direction = "horizontal",
                                                                  title.position="top",
                                                                  barwidth=8)) +
    ggplot2::scale_y_reverse(name="",
                             breaks=c(min(metadata(umi4c)$scales),
                                     max(metadata(umi4c)$scales)),
                             expand=c(0,0)) +
    ggplot2::scale_x_continuous(labels=function(x) round(x/1e6,2),
                                name=paste("Coordinates",
                                            GenomicRanges::seqnames(bait(umi4c)),
                                            "(Mb)")) +
    ggplot2::coord_cartesian(xlim=xlim) +
    ggplot2::guides(fill=ggplot2::guide_colorbar(title.position="left",
                                                 label.position="bottom",
                                                 title.vjust=1,
                                                 direction="horizontal"))

  return(dgram_plot)
}

#' Plot adaptative smoothen trend
#'
#' @inheritParams plotUMI4C
#' @importFrom stats sd
#' @export
plotTrend <- function(umi4c,
                      grouping="condition",
                      colors=NULL,
                      xlim=NULL,
                      ylim=NULL) {
  factors <- unique(colData(umi4c)[,grouping])
  if (class(factors)=="DataFrame") factors <- do.call(paste,  as.list(colData(umi4c)[,grouping]))
    if (is.null(colors)) colors <- getColors(factors)

  ## Construct trend
  trend_df <- trend(umi4c)

  if (length(grouping)==1) {
    trend_df <-
      trend_df %>%
      dplyr::group_by_at(c(grouping, "id_contact")) %>%
      dplyr::summarise(geo_coord=mean(geo_coord),
                trend=sum(trend),
                sd=mean(sd),
                scale=mean(scale))
  }

  if (is.null(ylim)) ylim <- c(0, max(trend_df$trend))

  trend_df$relative_position <- "upstream"
  trend_df$relative_position[trend_df$geo_coord>GenomicRanges::start(bait(umi4c))] <- "downstream"
  trend_df$grouping_var <- do.call(paste, trend_df[,grouping])

  trend_plot <-
    ggplot2::ggplot(trend_df) +
    ggplot2::geom_ribbon(ggplot2::aes(geo_coord, ymin=trend-sd, ymax=trend+sd,
                                      group=interaction(grouping_var, relative_position),
                                      fill=grouping_var),
                         alpha=0.3, color=NA) +
    ggplot2::geom_line(ggplot2::aes(geo_coord, trend,
                                    group=interaction(grouping_var, relative_position),
                                    color=grouping_var)) +
    ggplot2::scale_color_manual(values=colors,
                                name="Trend group",
                                guide=ggplot2::guide_legend(ncol=1)) +
    ggplot2::scale_fill_manual(values=colors,
                                name="Trend group",
                               guide=ggplot2::guide_legend(ncol=1)) +
    ggplot2::annotate("point", x=GenomicRanges::start(bait(umi4c)), y=max(ylim),
                      color="black", fill="black", pch=25, size=4) +
    ggplot2::coord_cartesian(xlim=xlim, ylim=ylim) +
    ggplot2::scale_y_continuous(name="UMIs normalized trend",
                                breaks=scales::pretty_breaks(),
                                expand=c(0,0)) +
    ggplot2::scale_x_continuous(labels=function(x) round(x/1e6,2),
                                name=paste("Coordinates",
                                           GenomicRanges::seqnames(bait(umi4c)),
                                           "(Mb)")) +
    ggplot2::theme(legend.position="bottom")

  return(trend_plot)
}

#' Plot genes
#'
#' @param window GRanges object with coordinates from which to plot existing genes.
#' @inheritParams plotUMI4C
#' @export
plotGenes <- function(window,
                      protein_coding=TRUE,
                      longest=TRUE,
                      xlim=NULL) {

  ## Get gene names in region
  genes_sel <- unique(IRanges::subsetByOverlaps(hg19_gene_annoation_ensemblv75, window))

  if(protein_coding) genes_sel <- genes_sel[genes_sel$gene_biotype=="protein_coding",]
  if(longest) {
    tx_ids_sel <- unique(genes_sel$tx_id[genes_sel$longest])
    genes_sel <- genes_sel[genes_sel$tx_id %in% tx_ids_sel]
  }
  ## Edit genes
  distance <- GenomicRanges::width(window)*0.01

  ## Add stepping
  genes_step <- addStepping(genes_sel[genes_sel$type=="GENE",], window, 2)
  genes_uni <- data.frame(genes_step)

  genes_exon <- data.frame(genes_sel[genes_sel$type=="EXON",])
  genes_exon <- dplyr::left_join(genes_exon,
                                 genes_uni[,c(8,12)],
                                 by=c(tx_id="tx_id"))


  ## Plot genes--------------
  genesPlot <-
    ggplot2::ggplot(data=genes_uni) +
    ggplot2::geom_segment(data=genes_uni,
                          ggplot2::aes(x=start, y=stepping,
                                       xend=end, yend=stepping)) +
    ggplot2::geom_rect(data=genes_exon,
                       ggplot2::aes(xmin=start, xmax=end,
                                    ymin=(stepping-0.3), ymax=(stepping+0.3)),
                       fill="grey39", color="grey39") +
    ggplot2::geom_text(data=genes_uni,
                       ggplot2::aes(x=end, y=stepping, label=gene_name),
                       colour="black",
                       hjust=0, fontface=3, nudge_x=distance,
                       size=3) +
    ggplot2::coord_cartesian(xlim=xlim)

  return(genesPlot)

}

#' Add stepping for plotting genes
#'
#' Given a GRanges dataset representing genes, will add an arbitrary value for them to be plotted in
#' the Y axis without overlapping each other.
#' @param genesDat GRanges object containing gene information.
#' @param coordinates GRanges object with coordinates you want to plot.
#' @param mcol.name Integer containing the column number that contains the gene name.
#' @import GenomicRanges
addStepping <- function(genesDat,
                        coordinates,
                        mcol.name) {
  ## Create extension for avoiding overlap with gene names
  ext <- sapply(mcols(genesDat)[,mcol.name], nchar) * width(coordinates)/30
  genesDat.ext <- regioneR::extendRegions(genesDat, extend.end=ext)

  ## Add stepping to data
  genesDat$stepping <- disjointBins(genesDat.ext,
                                    ignore.strand=TRUE)

  return(genesDat)
}

#' Darken colors
#'
#' @param color Character containing the name or hex value of a color.
#' @param factor Numeric representing a factor by which darken the specified color.
darken <- function(color, factor=1.4){
  col <- grDevices::col2rgb(color)
  col <- col/factor
  col <- grDevices::rgb(t(col), maxColorValue=255)
  col
}


#' Theme X blank
#' @param ... Additional arguments to pass to the theme call from ggplot2.
#' @export
themeXblank <- function(...) {
  ggplot2::theme(axis.text.x=ggplot2::element_blank(),
                 axis.title.x=ggplot2::element_blank(),
                 axis.line.x=ggplot2::element_blank(),
                 axis.ticks.x=ggplot2::element_blank(),
                 ...)
}

#' Theme Y blank
#' @inheritParams themeXblank
#' @export
themeYblank <- function(...) {
  ggplot2::theme(axis.text.y=ggplot2::element_blank(),
                 axis.title.y=ggplot2::element_blank(),
                 axis.line.y=ggplot2::element_blank(),
                 axis.ticks.y=ggplot2::element_blank(),
                 ...)
}

#' Theme Y blank
#' @inheritParams themeXblank
#' @export
themeXYblank <- function(...) {
  ggplot2::theme(axis.text.x=ggplot2::element_blank(),
                 axis.title.x=ggplot2::element_blank(),
                 axis.line.x=ggplot2::element_blank(),
                 axis.ticks.x=ggplot2::element_blank(),
                 axis.text.y=ggplot2::element_blank(),
                 axis.title.y=ggplot2::element_blank(),
                 axis.line.y=ggplot2::element_blank(),
                 axis.ticks.y=ggplot2::element_blank(),
                 ...)
}

#' Get default colors
#'
#' @param factors Name of the factors that will be used for grouping variables.
getColors <- function(factors) {
    if (length(factors)==2) {
      colors <- c("darkorchid3", "darkorange3")
    } else if (length(factors)>2) {
      colors <- RColorBrewer::brewer.pal(n=length(factors), name="Set1")
    } else if (length(factors)==1) {
      colors <- "darkorchid3"
    }
  return(colors)
}

