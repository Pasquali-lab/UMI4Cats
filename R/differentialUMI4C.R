#' Differential UMI4C contacts using Fisher's Exact test
#'
#' Using the UMIs inside \code{query_regions} performs Fisher's Exact test to
#' calculate significant differences between contact intensities.
#' @param umi4c UMI4C object as generated by \code{makeUMI4C} or the
#' \code{UMI4C} constructor.
#' @param grouping Name of the \code{colData(UMI4C)} column that will be used
#' for grouping the UMI4C profiles
#' and performing differential analyses.
#' @param query_regions \code{GenomicRanges} object or \code{data.frame}
#' containing the region coordinates used to perform the differential analysis.
#' @param resize Width in base pairs for resizing the \code{query_regions}.
#' Default: no resizing.
#' @param window_size If \code{query_regions} are not defined, wil bin region in
#'  \code{window_size} bp and perform the analysis using this windows.
#' @param filter_low Either the minimum median UMIs requiered to perform
#' Fisher's Exact test or \code{FALSE} for performing the test in all windows.
#' @param padj_method Method for adjusting p-values. See
#' \code{\link[stats]{p.adjust}} for the different methods.
#' @param padj_threshold Numeric indicating the adjusted p-value threshold to
#' use to define significant differential contacts.
#' @return Calculates statistical differences between UMI-4C experiments.
#' @details In order to calculate differential contact intensities, this fuction
#'  first sums all UMIs for each grouping condition. Then, calculates the
#'  overlap of fragment ends with either the provided \code{query_regions} or
#'  the binned region using \code{window_size}. The resulting number of UMIs in
#'  each \code{query_region} will be the \emph{sum} of UMIs in all overlapping
#'  fragment ends. As a default, will filter out those regions whose median
#'  UMIs are lower than \code{filter_low}.
#'
#' Finally, a contingency table for each \code{query_reegions} or \code{window}
#' that passed the \code{filter_low} filter is created as follows:
#' \tabular{rcc}{
#'      \tab \emph{query_region} \tab \emph{region}\cr
#'     \emph{Reference} \tab n1 \tab N1-n1\cr
#'     \emph{Condition} \tab n2 \tab N2-n2
#'     }
#' and the Fisher's Exact test is performed. Obtained p-values are then
#' converted to adjusted p-values using \code{padj_method} and the results list
#' is added to the \code{UMI4C} object.
#' @examples
#' # Create example UMI4C-class object with helper function
#' umi <- makeUMI4Cexample()
#'
#' # Perform differential test
#' umi <- fisherUMI4C(umi, filter_low=30)
#' results(umi)
#' @export
fisherUMI4C <- function(umi4c,
                        grouping="condition",
                        query_regions,
                        resize=NULL,
                        window_size=5e3,
                        filter_low=50,
                        padj_method="fdr",
                        padj_threshold=0.05) {

  factor <- unique(colData(umi4c)[, grouping])

  if (length(factor)!=2) stop("Incorrect 'grouping' variable, it should divide your data in two groups.")

  if (missing(query_regions)) {
    query_regions <- unlist(GenomicRanges::tile(metadata(umi4c)$region,
                                                width=window_size))
    # Remove query regions overlapping with bait
    query_regions <- IRanges::subsetByOverlaps(query_regions,
                                               GenomicRanges::resize(bait(umi4c), width=3e3, fix="center"),
                                               invert=TRUE)
  } else {
    if (is(query_regions, "data.frame")) query_regions <- regioneR::toGRanges(query_regions)
  }

  if (ncol(mcols(query_regions))==0)
    query_regions$id <- paste0("region_", seq_len(length(query_regions)))
  else if (length(unique(mcols(query_regions)[1]))==length(query_regions))
    colnames(mcols(query_regions))[,1] <- "id"
  else
    query_regions$id <- paste0("region_", seq_len(length(query_regions)))

  ids_ref <- colData(umi4c)$sampleID[grep(factor[1], colData(umi4c)[,grouping])]
  ids_cond <- colData(umi4c)$sampleID[grep(factor[2], colData(umi4c)[,grouping])]

  row_ranges <- rowRanges(umi4c)
  umis <- assays(umi4c)$umis

  row_ranges$umis_ref <- rowSums(umis[,ids_ref, drop=FALSE])
  row_ranges$umis_cond <-  rowSums(umis[,ids_cond, drop=FALSE])

  total_ref <- sum(row_ranges$umis_ref, na.rm=TRUE)
  total_cond <- sum(row_ranges$umis_cond, na.rm=TRUE)

  # Resize query regions if value provided
  if(!is.null(resize)) query_regions <- GenomicRanges::resize(query_regions,
                                                              width=resize,
                                                              fix="center")

  # Find overlaps between fragment ends and query regions
  ols <- GenomicRanges::findOverlaps(row_ranges, query_regions)

  # Sum UMIs
  fends_split <- GenomicRanges::split(mcols(row_ranges)[queryHits(ols),],
                                      query_regions$id[subjectHits(ols)])
  fends_summary <- lapply(fends_split,
                          function(x) data.frame(umis_ref=sum(x$umis_ref,
                                                              na.rm=TRUE),
                                                 umis_cond=sum(x$umis_cond,
                                                               na.rm=TRUE)))
  fends_summary <- do.call(rbind, fends_summary)
  fends_summary$query_id <- names(fends_split)

  counts <- fends_summary[,c(3,1,2)]

  # Filter regions with low UMIs to avoid multiple testing
  if (filter_low) {
    median <- apply(fends_summary[,c(1,2)], 1, median) >= filter_low
    fends_summary <- fends_summary[median,]

    if (nrow(fends_summary)==0) stop("Your filter_low value is too high and removes all query_regions. Try setting a lower value or setting it to 'FALSE'")
  }


  mat_list <- lapply(seq_len(nrow(fends_summary)),
                     function(x) matrix(c(as.vector(t(fends_summary[x,c(2,1)])),
                                          total_cond-fends_summary[x,2],
                                          total_ref-fends_summary[x,1]),
                                        ncol=2,
                                        dimnames=list(c("cond", "ref"),
                                                      c("query", "region"))))

  fends_summary$pvalue <- unlist(lapply(mat_list,
                                        function(x) stats::fisher.test(x)$p.value))
  fends_summary$odds_ratio <- unlist(lapply(mat_list,
                                            function(x) stats::fisher.test(x)$estimate))
  fends_summary$log2_odds_ratio <- log2(fends_summary$odds_ratio)
  fends_summary$padj <- stats::p.adjust(fends_summary$pval, method=padj_method)

  fends_summary$sign <- FALSE
  fends_summary$sign[fends_summary$padj<=padj_threshold] <- TRUE


  umi4c@results <- S4Vectors::SimpleList(test="Fisher's Exact Test",
                                         ref=factor[1],
                                         padj_threshold=padj_threshold,
                                         results=fends_summary[,-c(1,2)],
                                         query=query_regions,
                                         counts=counts)

  return(umi4c)
}

#' Differential UMI4C contacts using DESeq2 Wald Test
#'
#' @param umi4c UMI4C object as generated by \code{makeUMI4C} or the
#' \code{UMI4C} constructor.
#' @param design A \code{formula} or \code{matrix}. The formula expresses how
#' the counts for each fragment end depend on the variables in \code{colData}.
#' See  \code{\link[DESeq2]{DESeqDataSet}}
#' @param normalized Logical indicating if the function shoult return normalized
#'  or raw UMI counts.
#' @param padj_method The method to use for adjusting p-values, see
#' \code{\link[stats]{p.adjust}}
#' @param query_regions \code{GRanges} object or \code{data.frame} containing
#' the coordinates of the genomic regions you want to use to perform the
#' analysis in specific genomic intervals.
#' @param padj_threshold Numeric indicating the adjusted p-value threshold to
#' use to define significant differential contacts.
#' @param ... Other arguments to be passed to \code{\link[DESeq2]{DESeq}}
#' function.
#' @return Differential results using DESeq2.
#' @import GenomicRanges
deseq2UMI4C <- function(umi4c,
                        design= ~ condition,
                        normalized=TRUE,
                        padj_method="fdr",
                        query_regions=NULL,
                        padj_threshold=0.05,
                        ...) {
  if (is(query_regions, "data.frame")) query_regions <- regioneR::toGRanges(query_regions)

  dds <- DESeq2::DESeqDataSetFromMatrix(countData=assays(umi4c)$umis,
                                        colData=colData(umi4c),
                                        rowRanges=rowRanges(umi4c),
                                        design=design)

  if(!is.null(query_regions)) {
    dds <- subsetByOverlaps(dds, query_regions)
    query_regions <- rowRanges(dds)
    colnames(mcols(query_regions))[1] <- "id"
  } else {
    query_regions <- rowRanges(umi4c)
    colnames(mcols(query_regions))[1] <- "id"
  }

  dds <- DESeq2::DESeq(dds,
                       ...)

  res <- DESeq2::results(dds,
                         pAdjustMethod=padj_method)

  res <- data.frame(res[,c(5,2,6)])
  res$query_id <- rownames(res)
  res$sign <- FALSE
  res$sign[res$padj<=padj_threshold] <- TRUE

  counts <- as.data.frame(counts(dds, normalized=normalized))
  counts$query_id <- rownames(counts)
  counts <- counts[,c(ncol(counts), seq_len(ncol(counts)-1))]

  umi4c@results <- S4Vectors::SimpleList(test="DESeq2 Test based on the Negative Binomial distribution",
                                         ref=DESeq2::resultsNames(dds)[2],
                                         padj_threshold=padj_threshold,
                                         results=res[,c(4,1,2,3,5)],
                                         query=query_regions,
                                         counts=counts)

  return(umi4c)
}
